2.7
Syntax parser
a program that reads your code and determines what it does and if it is valid gramatically
interpriters and compilers - check that

Lexical Environment (word related / valubulary)
where it is written, what surrounds that

Execution context
a wrapper to help manage the code that is running

================


2.8
name /value pairs are straight forward
Objects are a collection of name/value pairs (in JavaScript. May be not in other languages)

================


2.10
Execution context
Base execution context is the global execution context

JavaScript Engine

JavaScript Engine (in Global Execution Context) creates two things for you; (we dont have to create it in the code)
Global Objects, this

for example, in a browser,
each tab will have a separate global object, which is the 'window'.
But in node env, this is not the window

In a code level, global is just 'not inside a function'

ToCheck:
but even we dont have javascript, we can access this??

================


2.15
Invocation is done using paranthesis
execution stack
when u invoke a function in js, a new exec context is created and put on top of execution stack
and then starts executing line by line. But if it reaches another function invocation, it creates another execution
context and put on the execution stack
This is true even if the function calls itself
JS is synchronous
and single threaded


2.16
Variable Environment: where the variables live
every execution context will have it's own variable Environment
execution context vs variable environment?
scope is the same?


2.17
js cares about the lexical environment when it wants to reference the outer reference
even though a function b is called inside function a, if the b function is written in the global execution context,
it looks for the variables there.
scope chain

2.18
scope: where a variable is available in your code
block scoping
"let" -> 
1. only available for the current block - block scoping
2. during the execution phase, it is added to memory and set to undefined as usual.
but the engine won't allow you to use it until it is declared (until the line of declaration is called). not hoisted?

2.19
Asynchronous: more than one at a time
JS engine is synchronous. But the other parts (engines) of the browser are Asynchronous
Event Queue is a seperate list in the js Engine
this is full of notifications of events
event eg: data requested is finished now!

JS looks at the event queue ONLY when the execution stack is empty. Periodically, JS looks at the event queue
The browser is the one who runs asynchronously
event loop is that continuous check

3.20
Dynamic typing: you dont tell the engine what type of data a variable holds
As opposed to Static typing

Primitive types: A single value. Not an Object
6 primitive type;
1. undefined: represents a lack of a value. you should NOT explicitly set this value
2. null: also represents a lack of value. You can assign this. No issue
3. boolean: true or false
4. number: a floating point number
5. string: both "" and '' can be used
6. symbol: from ES6


